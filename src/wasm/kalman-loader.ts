// RealMotionEngine Kalman Filter WASM loader
// Provides a typed interface to the Kalman filter WASM module

let modulePromise: Promise<any> | null = null;

// Interface for the Kalman filter
export interface KalmanFilter {
  create(dimensions: number, processNoise: number, measurementNoise: number): number;
  update(handle: number, measurement: number[]): number[];
  destroy(handle: number): void;
}

// Interface for demo functions
export interface KalmanDemo {
  generateNoisySine(count: number, frequency: number, amplitude: number, noiseLevel: number): number[];
  demoKalmanFilter(count: number): number[];
  freeData(dataPointer: number): void;
}

// Combined interface
export interface KalmanModule extends KalmanFilter, KalmanDemo {}

// Load the Kalman module (lazy loaded on first use)
export async function loadKalmanModule(): Promise<KalmanModule> {
  if (!modulePromise) {
    // Dynamic import the generated JS glue code
    // @ts-ignore - Module will be generated by Emscripten at build time
    modulePromise = import('./kalman')
      .then(module => module.createKalmanModule())
      .catch(err => {
        console.error('Failed to load Kalman WASM module:', err);
        // Provide a fallback that does nothing for development without Emscripten
        return {
          _kf_create: () => 1,
          _kf_update: () => [],
          _kf_destroy: () => {},
          _generate_noisy_sine: () => 0,
          _demo_kalman_filter: () => 0,
          _free_data: () => {},
          _malloc: () => 0,
          _free: () => {}
        };
      });
  }
  
  const wasmModule = await modulePromise;
  
  // Wrap the raw WASM functions in a nicer TypeScript interface
  return {
    // Kalman filter functions
    create: (dimensions: number, processNoise: number, measurementNoise: number): number => {
      return wasmModule._kf_create(dimensions, processNoise, measurementNoise);
    },
    
    update: (handle: number, measurement: number[]): number[] => {
      // In a real implementation, this would convert the array to WASM memory
      // For example:
      const heapPtr = wasmModule._malloc(measurement.length * 8);
      const dataView = new Float64Array(wasmModule.HEAPF64.buffer, heapPtr, measurement.length);
      dataView.set(measurement);
      
      const resultPtr = wasmModule._kf_update(handle, heapPtr, measurement.length);
      
      // Copy the result
      const result = Array.from(new Float64Array(
        wasmModule.HEAPF64.buffer, 
        resultPtr, 
        measurement.length
      ));
      
      wasmModule._free(heapPtr);
      return result;
    },
    
    destroy: (handle: number): void => {
      wasmModule._kf_destroy(handle);
    },
    
    // Demo functions
    generateNoisySine: (count: number, frequency: number, amplitude: number, noiseLevel: number): number[] => {
      const resultPtr = wasmModule.ccall(
        'generate_noisy_sine', 
        'number',
        ['number', 'number', 'number', 'number'],
        [count, frequency, amplitude, noiseLevel]
      );
      
      // Copy the result to a JavaScript array
      const result = Array.from(new Float64Array(
        wasmModule.HEAPF64.buffer, 
        resultPtr / Float64Array.BYTES_PER_ELEMENT, 
        count
      ));
      
      return result;
    },
    
    demoKalmanFilter: (count: number): number[] => {
      const resultPtr = wasmModule.ccall(
        'demo_kalman_filter', 
        'number',
        ['number'],
        [count]
      );
      
      // Copy the result to a JavaScript array
      const result = Array.from(new Float64Array(
        wasmModule.HEAPF64.buffer, 
        resultPtr / Float64Array.BYTES_PER_ELEMENT, 
        count
      ));
      
      return result;
    },
    
    freeData: (dataPointer: number): void => {
      wasmModule._free_data(dataPointer);
    }
  };
} 